package jvm;

public class 垃圾回收原理 {
    public Object instance = null;
    private static int _1MB = 1024*1024;
    private byte[] bigSize = new byte[2* _1MB];
    public static void testGC (){
        垃圾回收原理 l = new 垃圾回收原理();
        垃圾回收原理 l1 = new 垃圾回收原理();
        l.instance = l1;
        l1.instance = l;
        l = null;
        l1 = null;
        //垃圾回收机制
        System.gc();
    }

    public static void main(String[] args) {
        testGC();
    }
    /**
     * 引用计数法：
     * 引用计数法描述的算法为：给对象增加一个引用计数器，每当有一个地方引用它时，计数器就+1；当引用失效时，计数器就-1；任何时刻计数器为0的对象就是不能再被使用的，即对象已“死”。
     * 引用计数法实现简单，判定效率也比较高，在大部分情况下都是一个比较好的算法。比如Python语言就是采用的引用计数法来进行内存管理的。
     * 但是，在主流的JVM中没有选用引用计数法来管理内存，最主要的原因是引用计数法无法解决对象的循环引用问题。
     */
    /**
     * 可达性分析
     * 在上面讲了，Java并不采用引用计数法来判断对象是否已“死”，而采用“可达性分析”来判断对象是否存活（同样采用此法的还有C#、Lisp-最早的一门采用动态内存分配的语言）。
     * 此算法的核心思想：通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为“引用链”，当一个对象到 GC Roots 没有任何的引用链相连时(从 GC Roots 到这个对象不可达)时，证明此对象不可用。以下图为例：
     *
     * 即一个对象必须有一个链是链接 GC roots的，这个对象是可用的活的。不会被回收。
     * 如果一个对象，没有一个链是链接 GC roots 的 这个对象就是不可用的，会被回收。
     *
     * 可以作为GC 的对象
     * 虚拟机栈(栈帧中的本地变量表)中引用的对象。
     * 方法区中静态属性引用的对象
     * 方法区中常量引用的对象
     * 本地方法栈中(Native方法)引用的对象
     *
     *
     *
     */
}
